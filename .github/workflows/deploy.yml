name: Deploy

on:
  push:
    branches: [ 'main' ]

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-tags: true
    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
    - name: Generate Semantic Version
      id: version
      run: |
        LATEST_VERSION=$(git tag --sort=-version:refname | grep '^v[0-9]' | head -1)
        if [ -z "$LATEST_VERSION" ]; then
          VERSION="v1.0.0"
        else
          if [[ "$LATEST_VERSION" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
            NEW_PATCH=$((PATCH + 1))
            VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          else
            VERSION="v1.0.0"
          fi
        fi
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "Final generated version: ${VERSION}"
    - name: Create and Push Tag
      id: create-tag
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if git rev-parse "$VERSION" >/dev/null 2>&1; then
          git tag -d "$VERSION"
          git push origin ":refs/tags/$VERSION" || echo "Tag deletion from remote failed (may not exist remotely)"
        fi
        git tag "$VERSION"
        git push origin "$VERSION"

  build-and-push:
    name: Build & Push
    needs: create-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Determine Version
      id: version
      run: |
        VERSION="${{ needs.create-release.outputs.version }}"
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "Using version: ${VERSION}"
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    - name: Extract Docker Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.DOCKERHUB_USERNAME }}/petrosa-socket-client
        tags: |
          type=raw,value=${{ steps.version.outputs.version }}
    - name: Build and Push Docker Image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ steps.version.outputs.version }}
          COMMIT_SHA=${{ github.sha }}
          BUILD_DATE=${{ steps.meta.outputs.date }}

  deploy:
    name: Deploy to Kubernetes
    needs: [build-and-push, create-release]
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    - name: Configure kubectl for MicroK8s
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 --decode > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
        kubectl cluster-info --insecure-skip-tls-verify
        kubectl get nodes --insecure-skip-tls-verify
    - name: Update Image Tags in Manifests
      run: |
        IMAGE_TAG="${{ needs.build-and-push.outputs.version }}"
        find k8s/ -name "*.yaml" -o -name "*.yml" | xargs sed -i "s|VERSION_PLACEHOLDER|${IMAGE_TAG}|g"
        
        # Also replace the image name to use the correct format with secrets
        find k8s/ -name "*.yaml" -o -name "*.yml" | xargs sed -i "s|petrosa/petrosa-socket-client|${{ secrets.DOCKERHUB_USERNAME }}/petrosa-socket-client|g"
        
        echo "Updated manifests with image: ${{ secrets.DOCKERHUB_USERNAME }}/petrosa-socket-client:${IMAGE_TAG}"
        
        # Verify the changes
        echo "Verifying image tag updates:"
        grep -r "image:.*petrosa-socket-client" k8s/ || echo "No image references found"
        
        # Double-check that no VERSION_PLACEHOLDER remain
        PLACEHOLDER_COUNT=$(grep -r "VERSION_PLACEHOLDER" k8s/ | wc -l || echo "0")
        if [ "$PLACEHOLDER_COUNT" -gt 0 ]; then
          echo "‚ö†Ô∏è Warning: Found $PLACEHOLDER_COUNT references to VERSION_PLACEHOLDER"
          grep -r "VERSION_PLACEHOLDER" k8s/
        else
          echo "‚úÖ All image references updated to versioned tag: ${IMAGE_TAG}"
        fi
    - name: Apply Kubernetes Manifests
      run: |
        kubectl apply --insecure-skip-tls-verify -f k8s/ -n ${{ env.NAMESPACE }}
    - name: Wait for deployment to be ready
      run: |
        kubectl rollout status deployment/petrosa-socket-client -n ${{ env.NAMESPACE }} --timeout=300s --insecure-skip-tls-verify

    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=socket-client --insecure-skip-tls-verify
        kubectl get svc -n ${{ env.NAMESPACE }} -l app=socket-client --insecure-skip-tls-verify
        kubectl get ingress -n ${{ env.NAMESPACE }} -l app=socket-client --insecure-skip-tls-verify

        echo ""
        echo "üìä Deployment Summary:"
        echo "  ‚úÖ Kubernetes resources deployed successfully"
        echo "  üê≥ Image: ${{ secrets.DOCKERHUB_USERNAME }}/petrosa-socket-client:${{ needs.build-and-push.outputs.version }}"
        echo "  üìç Namespace: ${{ env.NAMESPACE }}"
        echo "  üîó Service: petrosa-socket-client-service"
        echo "  üåê Ingress: petrosa-socket-client-ingress"
        echo ""
        echo "üîç Next steps:"
        echo "  1. Check that pods are running: kubectl get pods -n ${{ env.NAMESPACE }} --insecure-skip-tls-verify"
        echo "  2. Verify service is accessible: kubectl get svc -n ${{ env.NAMESPACE }} --insecure-skip-tls-verify"
        echo "  3. Check that the image can pull successfully"
        echo "  4. Test the API endpoints"
        echo "  5. Monitor application logs for any issues"
        echo ""
        echo "üîç Verify deployed image version:"
        echo "  kubectl get deployment -n ${{ env.NAMESPACE }} --insecure-skip-tls-verify -o jsonpath='{.items[*].spec.template.spec.containers[*].image}'"

  notify:
    name: notify
    needs: [build-and-push, deploy, create-release]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Notify Deployment Status
      run: |
        VERSION="${{ needs.create-release.outputs.version }}"
        TAG_CREATED="${{ needs.create-release.outputs.tag-created }}"
        IMAGE_TAG="${{ needs.build-and-push.outputs.version }}"
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "‚úÖ Deployment successful!"
          echo "üì¶ Version: ${VERSION}"
          echo "üê≥ Image Tag: ${IMAGE_TAG}"
          if [ "$TAG_CREATED" == "true" ]; then
            echo "üè∑Ô∏è  New tag created: ${VERSION}"
          else
            echo "üè∑Ô∏è  Using existing tag: ${VERSION}"
          fi
          echo "üöÄ Deployed to MicroK8s with versioned image tag"
        else
          echo "‚ùå Deployment failed!"
          echo "üì¶ Version: ${VERSION}"
          echo "üê≥ Image Tag: ${IMAGE_TAG}"
        fi

  cleanup:
    name: cleanup
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Clean Up Old Images
      run: |
        echo "Cleaning up old Docker images..."
